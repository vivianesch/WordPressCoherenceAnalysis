---
title: "Advanced R"
author: "Viviane Schneider"
date: "29/08/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Advanced R
1: Setting Up Swirl
2: Functions
3: Functional Programming with purrr

## 3: Functional Programming with purrr

Functional programming is a programming philosophy based on lambda calculus. Lambda calculus
was created by Alonzo Church, the PhD adviser to Alan Turing who is known for his role in
cracking the encryption of the Nazi’s Enigma machine during World War Two. Functional
programming has been a popular approach ever since it helped bring down the Third Reich.

Functional programming concentrates on four constructs - Data (numbers, strings, etc),
Variables (function arguments), Functions, and Function Applications (evaluating functions
given arguments and/or data).

There are groups of functions that are essential for functional programming. In most cases they take a function and a data structure as arguments, and that function is applied to that data structure in some way. The purrr library contains many of these functions and we’ll be using it throughout this lesson. Functional programming is concerned mostly with lists and vectors. I may refer to just lists or vectors, but you should know that what applies for lists generally applies for vectors and vice-versa.

 I have defined a few functions that we are going to use throughout this lesson. Take a moment
to familarize yourself with the documentation for these functions.

The first family of functions we'll be discussing are the Map functions.

The map family of functions applies a function to the elements of a data structure, usually a
list or a vector. The function is evaluated once for each element of the vector with the vector element as the first argument to the function. The return value is the same kind if data
structure (a list or vector) but with every element replaced by the result of the function being evaluated with the corresponding element as the argument to the function.

 In the purrr package the map() function returns a list, while the map_lgl(), map_chr(), and
map_dbl() functions return vectors of logical values, strings, or numbers respectively.

Enter map_chr(c(5, 3, 4), int_to_string) into the R console to map the int_to_string() function
to the vector c(5, 3, 4).

```{r map_chr}

map_chr(c(5, 3, 4), int_to_string)

```

Think about evaluating the int_to_string() function with just one of the arguments in the
specified numeric vector, and then combining all of those function results into one vector.
That's essentially how the map functions work!

Let's try using a function that has two arguments with a map function. Use map_lgl() to map the
function gt() to vector c(1, 2, 3, 4, 5) to see which elements of that vector are greater than
3. Make sure to specify the last argument of map_lgl() as b = 3.

```{r map_lgl}
map_lgl(c(1, 2, 3, 4, 5), gt, b = 3)

```

 The map_if() function takes as its arguments a list or vector containing data, a predicate
function, and then a function to be applied.

A predicate function is a function that returns TRUE or FALSE for each element in the provided
| list or vector. In the case of map_if(): if the predicate functions evaluates to TRUE, then the function is applied to the corresponding vector element, however if the predicate function
evaluates to FALSE then the function is not applied.

```{r map_if}

map_if(c(1, 2, 3, 4), is_even, square)

```

 Take a look at the output - all of the even numbers were squared while the odd numbers were
left alone! Notice that the map_if() function always returns a list.
Use the map_at() function to map square() to the first, third, and fourth element of the vector
c(4, 6, 2, 3, 8).


```{r map_at}
map_at(c(4, 6, 2, 3, 8), c(1, 3, 4), square)
```

In each of the previous examples we have only been mapping a function over one data structure,
however you can map a function over two data structures with the map2() family of functions.
The first two arguments should be two vectors of the same length, followed by a function which
will be evaluated with an element of the first vector as the first argument and an element of
the second vector as the second argument.
Use map2_chr() to apply the paste() function to the sequence of integers from 1 to 26 and all
the letters of the alphabet in lowercase.
```{r map2_chr}
map2_chr(letters, 1:26, paste)

```

 List or vector reduction iteratively combines the first element of a vector with the second
element of a vector, then that combined result is combined with the third element of the
vector, and so on until the end of the vector is reached. The function to be applied should
take at least two arguments. Where mapping returns a vector or a list, reducing should return a single value.

Reduce the vector c(1, 3, 5, 7) with the function add_talk() using the reduce() function.

```{r reduce}
reduce(c(1,3,5,7), add_talk)
```

On the first iteration x has the value 1 and y has the value 3, then the two values
are combined (they’re added together). On the second iteration x has the value of the
result from the first iteration (4) and y has the value of the third element in the
provided numeric vector (5). This process is repeated for each iteration.

Reduce the vector c("a", "b", "c", "d") into one string using the paste_talk()
function and the reduce() function.

```{r reduce}

reduce(c("a", "b", "c","d"), paste_talk)

```

By default reduce() starts with the first element of a vector and then the second
element and so on. In contrast the reduce_right() function starts with the last
element of a vector and then proceeds to the second to last element of a vector and so
on.


Reduce the vector c("a", "b", "c", "d") into one string using the paste_talk()
function and the reduce_right() function.

```{r reduce_right}
reduce_right(c("a", "b", "c", "d"), paste_talk)
```

Next we'll discuss fuctions for searching a list or a vector.

You can search for specific elements of a vector using the has_element() and detect()
functions. has_element() will return TRUE if a specified element is present in a
vector, otherwise it returns FALSE.

Use the has_element() function to see if the vector random_ints contains the number
45.

```{r}
has_element(random_ints, 45)

```

The detect() function takes a vector and a predicate function as arguments and it
returns the first element of the vector for which the predicate function returns TRUE.
Use detect() and is_even() to find the first element of random_ints that is an even
number.

