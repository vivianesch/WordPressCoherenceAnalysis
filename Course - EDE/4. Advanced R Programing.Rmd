---
title: "Advanced R"
author: "Viviane Schneider"
date: "29/08/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Advanced R
1: Functions
2: Functional Programming with purrr

## 1: Functions

Functions are one of the fundamental building blocks of the R language. They are small pieces
of reusable code that can be treated like any other R object.
Most functions in R return a value. Functions like Sys.Date() return a value based on
your computer's environment, while other functions manipulate input data in order to
compute a return value.


The mean() function takes a vector of numbers as input, and returns the average of all
of the numbers in the input vector. Inputs to functions are often called arguments.
Providing arguments to a function is also sometimes called passing arguments to that
function. Arguments you want to pass to a function go inside the function's
parentheses. Try passing the argument c(2, 4, 5) to the mean() function.

```{r functions}
# Today functions
Sys.Date()

#average
mean()

#making a function 

# Let me show you an example of a function I'm going to make up called
# increment(). Most of the time I want to use this function to increase the
# value of a number by one. This function will take two arguments: "number" and
# "by" where "number" is the digit I want to increment and "by" is the amount I
# want to increment "number" by. I've written the function below. 
#
# increment <- function(number, by = 1){
#     number + by
# }
#
# If you take a look in between the parentheses you can see that I've set
# "by" equal to 1. This means that the "by" argument will have the default
# value of 1.
#
# I can now use the increment function without providing a value for "by": 
# increment(5) will evaluate to 6. 
#
# However if I want to provide a value for the "by" argument I still can! The
# expression: increment(5, 2) will evaluate to 7. 
# 
# You're going to write a function called "remainder." remainder() will take
# two arguments: "num" and "divisor" where "num" is divided by "divisor" and
# the remainder is returned. Imagine that you usually want to know the remainder
# when you divide by 2, so set the default value of "divisor" to 2. Please be
# sure that "num" is the first argument and "divisor" is the second argument.
#
# Hint #1: You can use the modulus operator %% to find the remainder.
#   Ex: 7 %% 4 evaluates to 3. 
#
# Remember to set appropriate default values! Be sure to save this 
# script and type submit() in the console after you write the function.
remainder <- function(num, divisor = 2) {
  num %% divisor
}

#see the arguments of a function
 args(remainder)
 
 
# Let me show you an example of a function I'm going to make up called
# increment(). Most of the time I want to use this function to increase the
# value of a number by one. This function will take two arguments: "number" and
# "by" where "number" is the digit I want to increment and "by" is the amount I
# want to increment "number" by. I've written the function below. 
#
# increment <- function(number, by = 1){
#     number + by
# }
#
# If you take a look in between the parentheses you can see that I've set
# "by" equal to 1. This means that the "by" argument will have the default
# value of 1.
#
# I can now use the increment function without providing a value for "by": 
# increment(5) will evaluate to 6. 
#
# However if I want to provide a value for the "by" argument I still can! The
# expression: increment(5, 2) will evaluate to 7. 
# 
# You're going to write a function called "remainder." remainder() will take
# two arguments: "num" and "divisor" where "num" is divided by "divisor" and
# the remainder is returned. Imagine that you usually want to know the remainder
# when you divide by 2, so set the default value of "divisor" to 2. Please be
# sure that "num" is the first argument and "divisor" is the second argument.
#
# Hint #1: You can use the modulus operator %% to find the remainder.
#   Ex: 7 %% 4 evaluates to 3. 
#
# Remember to set appropriate default values! Be sure to save this 
# script and type submit() in the console after you write the function.

remainder <- function(num, divisor = 2) {
  remainder<-num / divisor
  return(remainder)
}

# Let me show you an example of a function I'm going to make up called
# increment(). Most of the time I want to use this function to increase the
# value of a number by one. This function will take two arguments: "number" and
# "by" where "number" is the digit I want to increment and "by" is the amount I
# want to increment "number" by. I've written the function below. 
#
# increment <- function(number, by = 1){
#     number + by
# }
#
# If you take a look in between the parentheses you can see that I've set
# "by" equal to 1. This means that the "by" argument will have the default
# value of 1.
#
# I can now use the increment function without providing a value for "by": 
# increment(5) will evaluate to 6. 
#
# However if I want to provide a value for the "by" argument I still can! The
# expression: increment(5, 2) will evaluate to 7. 
# 
# You're going to write a function called "remainder." remainder() will take
# two arguments: "num" and "divisor" where "num" is divided by "divisor" and
# the remainder is returned. Imagine that you usually want to know the remainder
# when you divide by 2, so set the default value of "divisor" to 2. Please be
# sure that "num" is the first argument and "divisor" is the second argument.
#
# Hint #1: You can use the modulus operator %% to find the remainder.
#   Ex: 7 %% 4 evaluates to 3. 
#
# Remember to set appropriate default values! Be sure to save this 
# script and type submit() in the console after you write the function.

remainder <- function(num, divisor = 2) {
  # Write your code here!
  # Remember: the last expression evaluated will be returned! 
  num %% divisor
}

# You can pass functions as arguments to other functions just like you can pass
# data to functions. Let's say you define the following functions:
#
# add_two_numbers <- function(num1, num2){
#    num1 + num2
# }
#
# multiply_two_numbers <- function(num1, num2){
#	num1 * num2
# }
#
# some_function <- function(func){
#    func(2, 4)
# }
#
# As you can see we use the argument name "func" like a function inside of 
# "some_function()." By passing functions as arguments 
# some_function(add_two_numbers) will evaluate to 6, while
# some_function(multiply_two_numbers) will evaluate to 8.
# 
# Finish the function definition below so that if a function is passed into the
# "func" argument and some data (like a vector) is passed into the dat argument
# the evaluate() function will return the result of dat being passed as an
# argument to func.
#
# Hints: This exercise is a little tricky so I'll provide a few example of how
# evaluate() should act:
#    1. evaluate(sum, c(2, 4, 6)) should evaluate to 12
#    2. evaluate(median, c(7, 40, 9)) should evaluate to 9
#    3. evaluate(floor, 11.1) should evaluate to 11

evaluate <- function(func, dat){
  # Write your code here!
  # Remember: the last expression evaluated will be returned! 
  func(dat)
}

#Let's take your new evaluate() function for a spin! Use evaluate to find the standard
#deviation of the vector c(1.4, 3.6, 7.9, 8.8).

evaluate(sd, c(1.4, 3.6, 7.9, 8.8))

# The idea of passing functions as arguments to other functions is an important and # fundamental concept in programming.

```

 You may be surprised to learn that you can pass a function as an argument without first
defining the passed function. Functions that are not named are appropriately known as
anonymous functions.

Let's use the evaluate function to explore how anonymous functions work. For the first
argument of the evaluate function we're going to write a tiny function that fits on one line.
In the second argument we'll pass some data to the tiny anonymous function in the first
argument.

Type the following command and then we'll discuss how it works: evaluate(function(x){x+1}, 6)


```{r}
evaluate(function(x){x+1}, 6)
```

 The first argument is a tiny anonymous function that takes one argument `x` and returns
`x+1`. We passed the number 6 into this function so the entire expression evaluates to 7.

Try using evaluate() along with an anonymous function to return the first element of the
vector c(8, 4, 0). Your anonymous function should only take one argument which should be a
variable `x`.

```{r}
evaluate(function(x){x[1]}, c(8, 4, 0))
```

Now try using evaluate() along with an anonymous function to return the last element
of the vector c(8, 4, 0). Your anonymous function should only take one argument
which should be a variable `x`.
```{r}
evaluate(function(x){x[length(x)]}, c(8, 4, 0))
```

For the rest of the course we're going to use the paste() function frequently. Type
?paste so we can take a look at the documentation for the paste function.

As you can see the first argument of paste() is `...` which is referred to as an ellipsis or
simply dot-dot-dot. The ellipsis allows an indefinite number of arguments to be passed into a function. In the case of paste() any number of strings can be passed as arguments and paste() will return all of the strings combined into one string.

Just to see how paste() works, type paste("Programming", "is", "fun!")


```{r paste}
paste("Programming", "is", "fun!")

# The ellipses can be used to pass on arguments to other functions that are
# used within the function you're writing. Usually a function that has the
# ellipses as an argument has the ellipses as the last argument. The usage of
# such a function would look like:
#
# ellipses_func(arg1, arg2 = TRUE, ...)
#
# In the above example arg1 has no default value, so a value must be provided
# for arg1. arg2 has a default value, and other arguments can come after arg2
# depending on how they're defined in the ellipses_func() documentation.
# Interestingly the usage for the paste function is as follows:
#
# paste (..., sep = " ", collapse = NULL)
#
# Notice that the ellipses is the first argument, and all other arguments after
# the ellipses have default values. This is a strict rule in R programming: all
# arguments after an ellipses must have default values. Take a look at the
# simon_says function below:
#
# simon_says <- function(...){
#   paste("Simon says:", ...)
# }
#
# The simon_says function works just like the paste function, except the
# begining of every string is prepended by the string "Simon says:"
#
# Telegrams used to be peppered with the words START and STOP in order to
# demarcate the beginning and end of sentences. Write a function below called 
# telegram that formats sentences for telegrams.
# For example the expression `telegram("Good", "morning")` should evaluate to:
# "START Good morning STOP"

telegram <- function(...){
  paste("START", ..., "STOP")
}

mad_libs <- function(...){
  args <- list(...)
  place <- args[["place"]]
  adjective <- args[["adjective"]]
  noun <- args[["noun"]]
  # Don't modify any code below this comment.
  # Notice the variables you'll need to create in order for the code below to
  # be functional!
  paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}

```

You're familiar with adding, subtracting, multiplying, and dividing numbers in R. To do this
you use the +, -, *, and / symbols. These symbols are called binary operators because they
take two inputs, an input from the left and an input from the right.

```{r}
# The syntax for creating new binary operators in R is unlike anything else in
# R, but it allows you to define a new syntax for your function. I would only
# recommend making your own binary operator if you plan on using it often!
#
# User-defined binary operators have the following syntax:
#      %[whatever]% 
# where [whatever] represents any valid variable name.
# 
# Let's say I wanted to define a binary operator that multiplied two numbers and
# then added one to the product. An implementation of that operator is below:
#
# "%mult_add_one%" <- function(left, right){ # Notice the quotation marks!
#   left * right + 1
# }
#
# I could then use this binary operator like `4 %mult_add_one% 5` which would
# evaluate to 21.
#
# Write your own binary operator below from absolute scratch! Your binary
# operator must be called %p% so that the expression:
#
#       "Good" %p% "job!"
#
# will evaluate to: "Good job!"

"%p%" <- function(left, right){ # Remember to add arguments!
  paste(left, right)
}

'I' %p% 'love' %p% 'R!'

```

## 2: Functional Programming with purrr

Functional programming is a programming philosophy based on lambda calculus. Lambda calculus
was created by Alonzo Church, the PhD adviser to Alan Turing who is known for his role in
cracking the encryption of the Nazi’s Enigma machine during World War Two. Functional
programming has been a popular approach ever since it helped bring down the Third Reich.

Functional programming concentrates on four constructs - Data (numbers, strings, etc),
Variables (function arguments), Functions, and Function Applications (evaluating functions
given arguments and/or data).

There are groups of functions that are essential for functional programming. In most cases they take a function and a data structure as arguments, and that function is applied to that data structure in some way. The purrr library contains many of these functions and we’ll be using it throughout this lesson. Functional programming is concerned mostly with lists and vectors. I may refer to just lists or vectors, but you should know that what applies for lists generally applies for vectors and vice-versa.

 I have defined a few functions that we are going to use throughout this lesson. Take a moment
to familarize yourself with the documentation for these functions.

The first family of functions we'll be discussing are the Map functions.

The map family of functions applies a function to the elements of a data structure, usually a
list or a vector. The function is evaluated once for each element of the vector with the vector element as the first argument to the function. The return value is the same kind if data
structure (a list or vector) but with every element replaced by the result of the function being evaluated with the corresponding element as the argument to the function.

 In the purrr package the map() function returns a list, while the map_lgl(), map_chr(), and
map_dbl() functions return vectors of logical values, strings, or numbers respectively.

Enter map_chr(c(5, 3, 4), int_to_string) into the R console to map the int_to_string() function
to the vector c(5, 3, 4).

```{r map_chr}

map_chr(c(5, 3, 4), int_to_string)

```

Think about evaluating the int_to_string() function with just one of the arguments in the
specified numeric vector, and then combining all of those function results into one vector.
That's essentially how the map functions work!

Let's try using a function that has two arguments with a map function. Use map_lgl() to map the
function gt() to vector c(1, 2, 3, 4, 5) to see which elements of that vector are greater than
3. Make sure to specify the last argument of map_lgl() as b = 3.

```{r map_lgl}
map_lgl(c(1, 2, 3, 4, 5), gt, b = 3)

```

 The map_if() function takes as its arguments a list or vector containing data, a predicate
function, and then a function to be applied.

A predicate function is a function that returns TRUE or FALSE for each element in the provided
| list or vector. In the case of map_if(): if the predicate functions evaluates to TRUE, then the function is applied to the corresponding vector element, however if the predicate function
evaluates to FALSE then the function is not applied.

```{r map_if}

map_if(c(1, 2, 3, 4), is_even, square)

```

 Take a look at the output - all of the even numbers were squared while the odd numbers were
left alone! Notice that the map_if() function always returns a list.
Use the map_at() function to map square() to the first, third, and fourth element of the vector
c(4, 6, 2, 3, 8).


```{r map_at}
map_at(c(4, 6, 2, 3, 8), c(1, 3, 4), square)
```

In each of the previous examples we have only been mapping a function over one data structure,
however you can map a function over two data structures with the map2() family of functions.
The first two arguments should be two vectors of the same length, followed by a function which
will be evaluated with an element of the first vector as the first argument and an element of
the second vector as the second argument.
Use map2_chr() to apply the paste() function to the sequence of integers from 1 to 26 and all
the letters of the alphabet in lowercase.
```{r map2_chr}
map2_chr(letters, 1:26, paste)

```

 List or vector reduction iteratively combines the first element of a vector with the second
element of a vector, then that combined result is combined with the third element of the
vector, and so on until the end of the vector is reached. The function to be applied should
take at least two arguments. Where mapping returns a vector or a list, reducing should return a single value.

Reduce the vector c(1, 3, 5, 7) with the function add_talk() using the reduce() function.

```{r reduce}
reduce(c(1,3,5,7), add_talk)
```

On the first iteration x has the value 1 and y has the value 3, then the two values
are combined (they’re added together). On the second iteration x has the value of the
result from the first iteration (4) and y has the value of the third element in the
provided numeric vector (5). This process is repeated for each iteration.

Reduce the vector c("a", "b", "c", "d") into one string using the paste_talk()
function and the reduce() function.

```{r reduce}

reduce(c("a", "b", "c","d"), paste_talk)

```

By default reduce() starts with the first element of a vector and then the second
element and so on. In contrast the reduce_right() function starts with the last
element of a vector and then proceeds to the second to last element of a vector and so
on.


Reduce the vector c("a", "b", "c", "d") into one string using the paste_talk()
function and the reduce_right() function.

```{r reduce_right}
reduce_right(c("a", "b", "c", "d"), paste_talk)
```

Next we'll discuss fuctions for searching a list or a vector.

You can search for specific elements of a vector using the has_element() and detect()
functions. has_element() will return TRUE if a specified element is present in a
vector, otherwise it returns FALSE.

Use the has_element() function to see if the vector random_ints contains the number
45.

```{r has_element}
has_element(random_ints, 45)

```

The detect() function takes a vector and a predicate function as arguments and it
returns the first element of the vector for which the predicate function returns TRUE.
Use detect() and is_even() to find the first element of random_ints that is an even
number.

```{r detect}
detect(random_ints, is_even)

```

The detect_index() function takes the same arguments as detect(), however it returns the index
of the provided vector which contains the first element that satisfies the predicate function.
Use detect_index() and is_even() to find the index of the first element of random_ints that is
an even number.

```{r detect_index}
detect_index(random_ints, is_even)

```

 The group of functions that includes keep(), discard(), every(), and some() are known
as filter functions. Each of these functions takes a vector and a predicate function as arguments.

For keep() only the elements of the vector that satisfy the predicate function are
returned while all other elements are removed. Use the keep() function with
random_ints and is_even() to extract the even elements of random_ints.

```{r keep}
keep(random_ints, is_even)

```

The discard() function works similarly, it only returns elements that don’t satisfy
the predicate function. Use discard() to filter out the even elements of random_ints.

```{r discard}
discard(random_ints, is_even)

```


The every() function returns TRUE only if every element in the vector satisfies the
predicate function, while the some() function returns TRUE if at least one element in
the vector satisfies the predicate function. Use every() to see if every value of
random_ints is less than 100.

```{r every}
every(random_ints, function(x){x < 100})

```

Finally let's talk about two functions - partial() and walk().

Partial application of functions can allow functions to behave a little like data structures.Using the partial() function from the purrr package you can specify some of the arguments of a function, and then partial() will return a function that only takes the unspecified arguments. Use partial() to create a new function caled gt_10 which returns TRUE if its only argument is greater than ten and FALSE otherwise.

```{r partial}

gt_10 <- partial(gt, b = 10)

gt_10(11)

```

Side effects of functions occur whenever a function interacts with the "outside world"
- reading or writing data, printing to the console, and displaying a graph are all
side effects. The results of side effects are one of the main motivations for writing
code in the first place! Side effects can be tricky to handle though, since the order
in which functions with side effects are executed often matters and there are
variables that are external to the program (the relative location of some data).


If you want to evaluate a function across a data structure you should use the walk()
function from purrr. Use walk() across the vector called mark_antony with the message
function.

 walk(mark_antony, message)
